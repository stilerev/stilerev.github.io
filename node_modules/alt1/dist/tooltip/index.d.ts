import * as a1lib from "alt1/base";
import * as OCR from "alt1/ocr";
import { ImgRef } from "alt1/base";
export type TooltipState = ReturnType<typeof TooltipReader.read>;
export default class TooltipReader {
    static maxw: number;
    static maxh: number;
    static offsetx: number;
    static offsety: number;
    farTooltip: boolean;
    lookabove: boolean;
    trackinactive: boolean;
    tracking: boolean;
    private trackcallback;
    private trackinterval;
    track(callback: (state: TooltipState) => any, interval?: number): void;
    stopTrack(): void;
    trackTick(): void;
    static drawOverlay(tooltip: TooltipState, ignoregroup?: boolean): void;
    /**
     * very fast check to see if a tooltip might exist
     * set up to true to check for tooltips above the mouse instead of under
     */
    static checkPossible(buf: ImageData | null, up: boolean, far: boolean): boolean;
    static getCaptArea(dir: -1 | 0 | 1, mousepos: a1lib.PointLike): a1lib.RectLike | undefined;
    static readImage(img: ImgRef, mouseAbs: a1lib.PointLike, dir: -1 | 1): {
        area: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        mousepos: {
            x: number;
            y: number;
            uncertainx: boolean;
        };
        readBankItem: any;
        readInteraction: any;
    } | null;
    static read(dir?: -1 | 1 | 0): {
        area: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        mousepos: {
            x: number;
            y: number;
            uncertainx: boolean;
        };
        readBankItem: any;
        readInteraction: any;
    } | null;
    static readBankItem(img: ImgRef, area: a1lib.RectLike): string;
    /**
     * @deprecated Not completed
     * @param area
     */
    static readInteraction(img: ImgRef, area: a1lib.RectLike): {
        debugArea: {
            x: number;
            y: number;
            w: number;
            h: number;
        };
        text: string;
        fragments: OCR.TextFragment[];
    };
    static searchBuffer(buffer: ImageData, x?: number, y?: number, w?: number, h?: number): {
        x: number;
        y: number;
        width: number;
        height: number;
    } | null;
    static attemptFill(buf: ImageData, x: number, y: number, diry: number): {
        x: number;
        y: number;
        width: number;
        height: number;
    } | null;
}
//# sourceMappingURL=index.d.ts.map