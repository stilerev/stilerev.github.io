import * as a1lib from "alt1/base";
import ActionbarReader, { LifeState } from "./actionbar";
import { Rect } from "alt1/base";
export { default as ActionbarReader, LifeState } from "./actionbar";
export interface AbilityInfoBare {
    id: string;
    icon: ImageData;
    cooldown: number;
}
type AbilBarId = "bar0" | "bar1" | "bar2" | "bar3" | "bar4";
type CaptAreas = Partial<{
    [T in AbilBarId]: a1lib.RectLike;
}>;
export default class AbilityReader<T extends AbilityInfoBare> {
    bars: AbilityBar<T>[];
    mainbar: AbilityBar<T> | null;
    barstates: {
        [name: string]: AbilityLoadout<T>;
    };
    captureRect: a1lib.Rect | null;
    actionbarReader: ActionbarReader;
    abilityimgs: T[] | null;
    lifestate: LifeState;
    hooks: {
        onbarshown: ((bar: AbilityLoadout<T>) => any) | null;
    };
    static imgs: {
        smallbarnumber: ImageData | null;
        settingscog: ImageData | null;
    };
    constructor(abilityimgs: T[]);
    find(img?: a1lib.ImgRef): number | null;
    getCaptAreas(): Partial<{
        bar0: a1lib.RectLike;
        bar1: a1lib.RectLike;
        bar2: a1lib.RectLike;
        bar3: a1lib.RectLike;
        bar4: a1lib.RectLike;
    }>;
    /**
     * @deprecated kinda needs rewrite to be efficient, use readallslotsinner manually instead
     * @param img
     */
    readAllSlots(img?: a1lib.ImgRef): void;
    readAllSlotsInner(capts: Partial<{
        [T in AbilBarId]: ImageData | null;
    }>, captareas: CaptAreas): void;
    finishTick(): void;
    readLife(buffer: ImageData, bufx: number, bufy: number): LifeState | null;
    overlayState(): void;
    visibleAbilities(): Generator<AbilityState<T>, void, undefined>;
    allAbilities(): Generator<AbilityState<T>, void, undefined>;
    mainbarAbilities(): Generator<AbilityState<T>, void, undefined>;
    allslots(): Generator<AbilityBarSlot<T>, void, undefined>;
}
interface AbilityBarTypeMeta {
    sec: boolean;
    step: {
        x: number;
        y: number;
    };
    rowstep: {
        x: number;
        y: number;
    };
    rowlen: number;
    length: number;
    detect: {
        x: number;
        y: number;
    };
    cog?: {
        x: number;
        y: number;
    };
    action?: {
        x: number;
        y: number;
    };
    num: {
        x: number;
        y: number;
    };
    id: string;
}
declare class AbilityBarSlot<T extends AbilityInfoBare> {
    x: number;
    y: number;
    index: number;
    bar: AbilityBar<T>;
    constructor(x: number, y: number, index: number, bar: AbilityBar<T>);
    getState(): AbilityState<T>;
}
interface AbilityLoadout<T extends AbilityInfoBare> {
    barid: string;
    visible: boolean;
    slots: AbilityState<T>[];
}
declare class AbilityBar<T extends AbilityInfoBare> {
    static types: {
        [key: string]: AbilityBarTypeMeta;
    };
    x: number;
    y: number;
    bounds: Rect;
    barid: string;
    slots: AbilityBarSlot<T>[];
    layout: AbilityBarTypeMeta;
    barstates: {
        [id: string]: AbilityLoadout<T>;
    };
    reader: AbilityReader<T>;
    constructor(reader: AbilityReader<T>, x: number, y: number, layout: AbilityBarTypeMeta, barstates: {
        [id: string]: AbilityLoadout<T>;
    });
    readBarNr(buffer: ImageData, bufx: number, bufy: number): string;
    overlay(): void;
}
export declare class AbilityState<T extends AbilityInfoBare = AbilityInfoBare> {
    static iconwidth: number;
    static iconheight: number;
    static overlayState: boolean;
    nextdetecttry: number;
    lastcooldown: number;
    lasttickcooldown: number;
    tickcooldown: number;
    cdchange: number;
    gcd: boolean;
    donetime: number;
    hadcd: boolean;
    cooldown: number;
    available: boolean;
    cdfraction: number;
    ability: T | null;
    hotkey: string;
    reader: AbilityReader<T> | null;
    constructor(reader: AbilityReader<T>);
    readAbility(data: ImageData, x: number, y: number): void;
    confirmCdArea(buffer: ImageData, x: number, y: number): boolean;
    debug: ImageData | null;
    readClock(buf: ImageData, abilx: number, abily: number): void;
    readhotkey(buf: ImageData, abilx: number, abily: number): void;
    overlayState(x: number, y: number): void;
    getAbility(buf: ImageData, abilx: number, abily: number): T | null;
}
//# sourceMappingURL=index.d.ts.map