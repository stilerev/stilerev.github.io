import * as a1lib from "alt1/base";
import { ImgRef, ImgRefData } from "alt1/base";
import * as OCR from "alt1/ocr";
type FontSetting = {
    name: string;
    lineheight: number;
    badgey: number;
    dy: number;
    def: OCR.FontDefinition;
};
export declare const defaultcolors: number[][];
type BoxCorner = a1lib.PointLike & {
    type: "hidden" | "full" | "legacy";
};
export type Chatbox = {
    rect: a1lib.Rect;
    timestamp: boolean;
    type: "main" | "cc" | "fc" | "gc" | "gcc" | "pc" | "gimc";
    leftfound: boolean;
    topright: BoxCorner;
    botleft: a1lib.PointLike;
    line0x: number;
    line0y: number;
};
export type ChatLine = {
    text: string;
    fragments: OCR.TextFragment[];
    basey: number;
};
export default class ChatBoxReader {
    readargs: {
        colors: number[];
    };
    minoverlap: number;
    diffRead: boolean;
    diffReadUseTimestamps: boolean;
    forwardnudges: ReadLineNudge[];
    backwardnudges: ReadLineNudge[];
    pos: {
        mainbox: Chatbox;
        boxes: Chatbox[];
    } | null;
    debug: null;
    overlaplines: ChatLine[];
    lastTimestamp: number;
    lastTimestampUpdate: number;
    addedLastread: boolean;
    font: FontSetting | null;
    lastReadBuffer: ImgRefData | null;
    readChatLine(box: Chatbox, imgdata: ImageData, imgx: number, imgy: number, font: FontSetting, ocrcolors: OCR.ColortTriplet[], linenr: number): ChatLine;
    read(img?: ImgRef | null): ChatLine[] | null;
    simplifyLine(str: string): string;
    matchLines(line1: string, line2: string): boolean;
    checkLegacyBG(buf: ImageData, x: number, y: number): boolean;
    find(imgornull?: ImgRef): {
        mainbox: never;
        boxes: Chatbox[];
    } | null;
    checkTimestamp(img: ImgRef, pos: any): boolean;
    static getMessageTime(str: string): number;
    static getFontColor(buffer: ImageData, x: number, y: number, w: number, h: number): [number, number, number, number];
}
type ReadLineContext = {
    addfrag: (frag: OCR.TextFragment) => void;
    leftx: number;
    rightx: number;
    baseliney: number;
    imgdata: ImageData;
    font: OCR.FontDefinition;
    badgedy: number;
    colors: [number, number, number][];
    text: string;
    fragments: OCR.TextFragment[];
    forward: boolean;
};
type ReadLineNudge = {
    name: string;
    match: RegExp;
    fn: (ctx: ReadLineContext, match: RegExpMatchArray) => boolean | undefined;
};
export {};
//# sourceMappingURL=index.d.ts.map